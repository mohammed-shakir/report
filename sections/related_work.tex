%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% -                    Related Work                        - %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related Work}
This section frames the thesis in four strands of prior work:
\begin{itemize}
  \item Hierarchical spatial indexing and pre-aggregation.
  \item Adaptive caching for spatial workloads.
  \item Cache consistency and invalidation with spatial scope.
  \item Hexagonal grid indexing (H3).
\end{itemize}

The goal is to motivate the chosen H3-guided middleware design and clarify how it differs from existing systems.

\subsection{Hierarchical spatial indexing and pre-aggregation}
A central idea behind the proposed middleware is to divide query footprints into grid cells so that repeated queries over similar regions can be identified and reused. Work on \emph{GeoBlocks} pre-aggregates point data into fine-grained cells and approximates query polygons by unions of those cells. The approximation error is bounded by the chosen cell size, and a trie-like cache reuses previous results for frequently queried regions, adapting to skew over time \cite{Winter2021_GeoBlocks}. Similarly, \emph{Adaptive Cell Trie (ACT)} speeds up point-in-polygon joins by combining multiresolution (quadtree-style) approximations with a radix-tree over cell identifiers; the design avoids most expensive geometric tests while offering user controlled precision \cite{Kipf2020_ACT}. Earlier systems such as \emph{Nanocubes} and the \emph{aR-tree} introduced in-memory spatio-temporal aggregation over hierarchical rectangles; they offer interactive performance but rely on rectangular partitions that can cause unbounded error for arbitrary polygons unless cell size is carefully managed \cite{Lins2013_Nanocubes,Papadias2001_aRtree}. Together, these works support a grid-based approach that supports multiresolution refinement near boundaries, exposes compact cell identifiers for fast lookup and reuse, and adapts well under workload skew properties leveraged with H3-based bucketing.

\subsection{Adaptive caching for spatial workloads}
Beyond indexing, several systems adapt caching to hotspot access patterns. \emph{STASH} is a distributed, in-memory middleware cache for hierarchical aggregations that chooses replicas based on query frequency and freshness, leading to large latency reductions and a higher query processing rate under skew \cite{Mitra2019_STASH}. \emph{GeoBlocks} cache also adapts automatically as regions get popular \cite{Winter2021_GeoBlocks}. At the opposite end of the stack, \emph{SAC} (Semantic Adaptive Caching) predicts future query windows on the client using partitioned spatial history and prefetches answers to improve responsiveness \cite{Liu2013_SAC}. Finally, \emph{Vecstra} proposes an OGC-compliant in-memory geospatial cache that integrates caching with standard WFS/WCS interfaces, which is useful when the server side must remain standards based, as in GeoServer/PostGIS deployments \cite{Wang2018_Vecstra}. Although not spatial per se, \emph{MinMaxCache} shows how an adaptive in-memory cache can trade the level of aggregation for interactive visualization latency with error, an idea that inspires the evaluation of H3 resolution choices and composition overheads in this thesis \cite{Maroulis2024_MinMaxCache}. The common thread is that caching should be driven by query semantics, popularity, and acceptable approximation, rather than being a static tile store; the middleware follows this line by caching vector results keyed by H3 cells and adapting to observed hotness.

\subsection{Cache consistency and spatially scoped invalidation}
Keeping cached results fresh is not easy when data and query scopes are spatial. Classic mobile computing studies introduced \emph{location dependent} invalidation: cached answers can become stale not only because the data change but also because the user moves outside a valid geographic scope \cite{Xu2003_TKDE_LocationInvalidation}. This led to approaches like \emph{Bit-Vector} with \emph{Compression and Implicit Scope Information}, which link cached items directly to their spatial validity regions \cite{Xu2003_TKDE_LocationInvalidation}. Related work on \emph{location dependent semantic caching} also organizes cache segments with explicit spatial scopes and uses them in replacement and validation \cite{Manica2005_LDSCM}. The practical takeaway for a server-side cache is to tie each cached entry to an explicit spatial footprint and to invalidate it on time-based expiry (TTL) and spatial overlap with changed features. The proposed design does exactly this: H3 cell keys define validity scopes, while TTL and Kafka-driven events provide temporal and event based invalidation hooks.

\subsection{Hexagonal grids and H3}
H3 is a hierarchical, global grid of hexagonal cells. Its properties include near-uniform area per resolution, consistent adjacency, and a clean hierarchical relation between resolutions that make it attractive for bucketing and composing spatial answers \cite{H3docs}. Empirical reports outside pure research also suggest that hexagons reduce visual and aggregation artifacts compared to rectangular geohashes for many analytics tasks \cite{Drapier2024_H3}. For our use case, H3 gives a compact key that is independent of the programming language (suitable for Redis), deterministic up/down-sampling across resolutions for composition, and a natural way to map data change events to affected cells for invalidation.

\subsection{Gap analysis}
To the best of current knowledge, none of the above combines, in a single end-to-end system, real-time, \emph{schema agnostic} hotspot detection external to the database via H3 bucketing over arbitrary WFS/WMS requests, \emph{adaptive} caching of vector query results at the middleware layer with measured trade-offs across grid resolutions, and \emph{event-driven} freshness via streaming updates (Kafka) that target exactly the overlapping H3 cells. \emph{Index and cache} systems either pre-compute specific analytics (GeoBlocks, STASH), focus on client-centric prediction (SAC), or discuss standards-compliant caching without fine-grained spatial invalidation (Vecstra). This thesis fills that gap by implementing and evaluating an H3-keyed Redis cache between GeoServer and PostGIS, and by quantifying how resolution, hit ratio, memory footprint, and invalidation policy interact under skewed workloads.
