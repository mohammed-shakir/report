%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% -                    Introduction                        - %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

\subsection{Background}
Operational web mapping stacks at geospatial service providers typically combine GeoServer for OGC-compliant services with a PostGIS spatial database. Raster map tiles can be served via WMS/WMTS endpoints, which predefine tile matrices to improve the delivery of rendered images \cite{OGC_WMTS}. In contrast, vector feature access through WFS exposes fine-grained queries over feature properties and geometries, enabling filtering, editing, and analytics workflows that do not align cleanly with fixed tile boundaries \cite{OGC_WFS}. On the database side, PostGIS provides spatial types and functions with GiST-based indexes that are important for performance \cite{PostGIS_Indexing}; yet when traffic is highly skewed toward a few urban “hotspot” regions, many requests repeatedly overlap in space and time, re-triggering similar queries and I/O. 

Conventional server-side caching (e.g., tile caches) mostly targets rasterized responses; it is less effective for vector queries with complex geometries, attribute filters, or dynamic layers. A better approach is to partition the query footprint into a spatial grid and reuse results for frequently accessed cells \cite{GeoServer_GeoWebCache_TileCaching}. Hexagonal hierarchical grids such as H3 provide near-uniform cell areas across resolutions, consistent neighbors, and identifiers that are convenient as cache keys and for aggregation across multiple zoom levels.

A spatial cache must also stay fresh because upstream data changes. Time-to-live (TTL) expiration gives a simple baseline, but event-driven invalidation, common in change-data-capture (CDC) pipelines built around streaming platforms, can invalidate only the affected spatial cells when features are updated. Combining TTL with event-driven invalidation improves freshness without discarding useful cache entries. Finally, an in-memory store such as Redis provides the fast access needed to reduce end-to-end latency on cache hits while keeping implementation complexity manageable within a middleware layer. This thesis builds on these observations to investigate an H3-keyed, Redis-backed cache between GeoServer and PostGIS, coupled with TTL and Kafka-driven invalidation to handle freshness under skewed spatial workloads.

\subsection{Motivation}
Workloads in operational web mapping services frequently show spatial skew: a small set of geographic areas attracts the majority of traffic, while large regions are queried infrequently. Recomputing overlapping vector queries in such hotspots increases latency and worsens database load even when spatial indexes are present. An H3-guided middleware cache provides three benefits: 
\begin{enumerate}
  \item Lower latency by serving popular regions from memory.
  \item Lower PostGIS CPU and I/O by avoiding redundant evaluations.
  \item Tunable trade-offs between hit ratio, memory footprint, and freshness by adjusting H3 resolution and invalidation policy.
\end{enumerate}

From a research perspective, this work bridges ideas from hierarchical spatial indexing, adaptive caching, and spatially scoped invalidation into a deployable component that complements, rather than replaces, existing OGC services. The outcome should be practical recommendations on when adaptive caching is worthwhile, which resolutions to use, how to size memory, and how to integrate event-driven invalidation. The study provides an end-to-end evaluation of H3-keyed caching for dynamic vector workloads, a setting that is less well served by conventional tile caches and has few publicly documented, reproducible benchmarks.

\subsection{Problem Statement}
Modern spatial data platforms serve diverse read workloads through GeoServer and PostGIS. In practice, user traffic is highly skewed; a small set of geographic areas (e.g., city centers) receives a disproportionate share of requests, while large regions are rarely accessed \cite{Pan_2017}. Under this skew, repeated evaluation of overlapping spatial queries increases latency, drives unnecessary CPU and I/O load in PostGIS, and may slow down downstream map rendering. Conventional tile oriented caching helps for pre-rendered map tiles \cite{OGC_WMTS}, but is less effective for dynamic vector queries, highly detailed filters \cite{OGC_WFS}, and requests that do not align with fixed tile boundaries \cite{Winter2021_GeoBlocks}. As a result, the platform needs a cache that adapts to \emph{where} and \emph{how often} users query, while remaining correct and fresh when data changes.

The problem addressed in this thesis is to design, implement, and evaluate an \emph{adaptive, spatially aware} caching layer that sits between GeoServer and PostGIS and uses an H3 hexagonal grid to detect hotspot regions from live query traffic, cache corresponding query results in Redis for low latency reuse, and keep cache entries acceptably fresh using a combination of time-to-live (TTL) and event driven invalidation from Kafka. The solution must reduce end-to-end query latency and database load under skewed workloads without introducing unacceptable staleness or excessive memory overhead. The study aims not only to derive actionable guidance on grid resolution, cache sizing, and invalidation policy, but also to deliver a prototype middleware that can be deployed in real production environments.

\subsection{Research Questions}
To evaluate the proposed approach, this thesis investigates the following research questions:

\begin{enumerate}
  \item \textbf{Effectiveness:} To what extent does H3-based adaptive caching reduce latency and offload query pressure from PostGIS compared to no caching or a simple geometry/TTL cache baseline under skewed workloads?
  \item \textbf{Granularity:} Which H3 resolution(s) give the best balance between cache hit ratio, memory footprint, and data freshness, given uneven access to different areas?
  \item \textbf{Invalidation Policies:} What combination of time-to-live (TTL) and event-driven invalidation (triggered by upstream data change notifications) provides acceptable staleness bounds while keeping high performance?
\end{enumerate}

\subsection{Scope}
The thesis develops and evaluates a middleware layer between GeoServer and PostGIS that encodes request footprints as H3 cells, caches vector query results in Redis, tracks hotness, and applies TTL and Kafka based invalidation. This includes building a working prototype that intercepts spatial requests and serves frequently accessed regions directly from Redis. Experiments will use containerized components and synthetic, skewed workloads representative of urban hotspots. The evaluation focuses on latency percentiles, database load, hit/miss ratios, staleness bounds, and cache memory usage across H3 resolutions, with an emphasis on quantifying the trade-offs among H3 resolution, cache size, hit ratio, and freshness.

\subsection{Contributions}
x

\subsection{Thesis Structure}
The thesis is organized as follows:
\begin{itemize}
  \item \textbf{Introduction} outlines the background, motivation, problem statement, research questions, scope, contributions, and thesis structure.
  \item \textbf{Related Work} surveys prior research on spatial indexing, adaptive caching, and cache consistency for dynamic geodata.
  \item \textbf{Theory} introduces the theoretical background needed to understand H3 indexing, caching principles, and consistency mechanisms.
  \item \textbf{Method} describes the H3-based request bucketing, hotness tracking, cache invalidation policies, and the middleware design.
  \item \textbf{Results} present the experimental setup and report findings across baselines and different H3 resolutions.
  \item \textbf{Discussion} reflects on the results, limitations, and threats to validity and includes considerations of sustainability.
  \item \textbf{Conclusions} summarize the contributions of the thesis and outline directions for future improvements and deployment.
\end{itemize}
